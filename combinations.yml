########################################################################
# RQG integration tests with DML and DDL, different engines.
# The default set is big bang, but it can be narrowed down through
# configuration parameters
########################################################################

trigger: none

jobs:

#########
# Download or build server
- template: jobs/prepare-server.yml
  parameters:
    name: 'Download_or_Build_Server'

#########
# Upload to FTP
- template: jobs/upload-to-ftp.yml
  parameters:
    dependencies:
    - 'Download_or_Build_Server'
    condition: and(succeeded(), ne(dependencies.Download_or_Build_Server.outputs['ftp_download.BINARIES_FROM_FTP'], 'true'))

#########
- job: Test
  timeoutInMinutes: 0
  dependsOn: Download_or_Build_Server
  pool:
    vmImage: 'Ubuntu 16.04'

  strategy:
    parallel: 10

  steps:

  - template: steps/env.yml

  - task: DownloadBuildArtifacts@0
    inputs:
      artifactName: 'build'
      downloadPath: $(Build.ArtifactStagingDirectory)
    displayName: 'Download build from artifacts'

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/build/build-*.tar.gz'
      destinationFolder: $(env.BASEDIR)
    displayName: 'Extract build'

  - template: steps/install-deb-packages.yml
    parameters:
      INSTALLATION_SET: 'runtime'

  - template: steps/clone-test-tools.yml

  - script: |
      start_time=`date +'%s'`
      end_time=$((start_time+ENV_RQG_DURATION))
      echo "JobName: $ENV_REAL_JOBNAME, start time"
      mkdir -p $ENV_LOGDIR
      set -xo pipefail
      cd $ENV_RQG_HOME
      export ASAN_OPTIONS="abort_on_error=1,disable_coredump=0"
      TRIAL_NO=0
      rm -rf $(Build.ArtifactStagingDirectory)/*
      while [ `date +'%s'` -lt $((end_time-300)) ]
      do
        perl ./combinations.pl \
          --basedir=$ENV_BASEDIR \
          --workdir=$ENV_LOGDIR \
          --config=$ENV_RQG_COMBINATIONS \
          --force \
          --discard-logs \
          --trials=1
        #
        echo "#"
        echo "# Result collection"
        echo "#"
        #
        mv $ENV_LOGDIR/trial1.log $ENV_LOGDIR/trial.log
        mv $ENV_LOGDIR/current1_1 $ENV_LOGDIR/vardir
        TRIAL_NO=$(($TRIAL_NO+1))
        echo "##vso[task.setvariable variable=TRIAL_NO]$TRIAL_NO"
        #
        RUN_ID=$(System.JobPositionInPhase).$TRIAL_NO
        echo "##vso[task.setvariable variable=RUN_ID]$RUN_ID"
        mkdir $(Build.ArtifactStagingDirectory)/$RUN_ID
        summary_dir=$(Build.ArtifactStagingDirectory)/$RUN_ID/summary-$(Build.BuildNumber).$RUN_ID
        details_dir=$(Build.ArtifactStagingDirectory)/$RUN_ID/data-$(Build.BuildNumber).$RUN_ID
        repro_dir=$(Build.ArtifactStagingDirectory)/$RUN_ID/repro-$(Build.BuildNumber).$RUN_ID
        mkdir -p $summary_dir $details_dir $repro_dir
        cp $ENV_LOGDIR/trial.log $ENV_RQG_HOME/rqg.info $ENV_BASEDIR/server.info $ENV_TOOLBOX_DIR/toolbox.info $summary_dir/
        cp --parents `find $ENV_LOGDIR -name mysql*err* | xargs` $summary_dir/
        cp --parents `find $ENV_LOGDIR -name mbackup*log* | xargs` $summary_dir/
        cp $ENV_LOGDIR/vardir/mysql.log $repro_dir/
        for c in `find $ENV_LOGDIR -name core*` ; do
          echo "#################### $c ####################" >> $summary_dir/stacktraces
          echo "#################### $c ####################" >> $details_dir/threads
          echo "#################### $c ####################" >> $details_dir/threads_full
          binary=`gdb --batch --eval-command="bt" 1 $c 2>&1 | grep -a 'Core was generated by' | sed -e 's/^Core was generated by \`\([^ ]*\) .*/\1/'`
          echo $binary >> $summary_dir/stacktraces
          echo $binary >> $details_dir/threads
          echo $binary >> $details_dir/threads_full
          gdb --batch --eval-command="bt" $binary $c  | grep -a -v 'New LWP' >> $summary_dir/stacktraces
          gdb --batch --eval-command="thread apply all bt" $binary $c >> $details_dir/threads
          gdb --batch --eval-command="thread apply all bt full" $binary $c >> $details_dir/threads_full
        done
        tar zcf $details_dir/logs.tar.gz $ENV_LOGDIR
        if [ -e $ENV_LOGDIR/trial.log ] ; then
          result_collection_options="--test-log=$ENV_LOGDIR/trial.log"
        fi
        for d in $ENV_LOGDIR/vardir* ; do
          result_collection_options="$result_collection_options --vardir=$d"
        done
        echo "" >> $summary_dir/test_report
        echo "Test $RUN_ID" >> $summary_dir/test_report
        # First choice: runall prints the status right before exit
        res=`grep -a 'runall.* will exit with exit status' $summary_dir/trial.log | sed -e 's/.*will exit with exit status STATUS_\([A-Z_]*\).*/\1/'`
        # Second choice: runall prints the status of GenTest after GenTest exited. It doesn't include final checks
        if [ -z "$res" ] ; then
          res=`grep -a 'GenTest exited with exit status' $summary_dir/trial.log | sed -e 's/.*exited with exit status STATUS_\([A-Z_]*\).*/\1/'`
        fi
        # Last choice: GenTest prints the status before exiting
        if [ -z "$res" ] ; then
          res=`grep -a 'GenTest will exit with exit status' $summary_dir/trial.log | sed -e 's/.*will exit with exit status STATUS_\([A-Z_]*\).*/\1/'`
        fi
        echo "Test result:" $res >> $summary_dir/test_report
        export TEST_RESULT=$res
        echo "Trigger ID:" $(System.DefinitionId)-$(Build.BuildId)-$(Build.BuildNumber).$RUN_ID >> $summary_dir/test_report
        echo "-------------------------------------" >> $summary_dir/test_report
        echo "" >> $summary_dir/test_report
        cp $summary_dir/server.info $repro_dir/repro.info
        rqg_cmd=`grep -a -A 1 'Final command line' $summary_dir/trial.log | tail -n 1`
        mysqld_options=""
        for o in $rqg_cmd ; do
          if expr match "$o" "--mysqld" > /dev/null ; then
            mysqld_options="$mysqld_options $o"
          fi
        done
        echo "" >> $repro_dir/repro.info
        echo "RQG command line: $rqg_cmd" >> $repro_dir/repro.info
        echo "MySQLd options: $mysqld_options" >> $repro_dir/repro.info
        echo `cat $summary_dir/rqg.info` `cat $summary_dir/toolbox.info` >> $summary_dir/test_report
        cat $repro_dir/repro.info >> $summary_dir/test_report
        export TEST_ID=$(Build.BuildId).$RUN_ID
        echo >> $summary_dir/test_report
        $ENV_TOOLBOX_DIR/scripts/collect_rqg_result_info.sh $result_collection_options > $summary_dir/result_info
        perl $ENV_RQG_HOME/util/check_for_known_bugs.pl --signatures=$ENV_RQG_HOME/data/bug_signatures $summary_dir/result_info >> $summary_dir/test_report
        echo >> $summary_dir/test_report
        echo "#####################################" >> $summary_dir/test_report
        cat $summary_dir/result_info >> $summary_dir/test_report
        echo "#####################################" >> $summary_dir/test_report
        cat $summary_dir/test_report
      done  
    displayName: Combinations
    env:
      DB_HOST: $(DbHost)
      DB_PORT: $(DbPort)
      DB_USER: $(DbUser)
      DBP: $(DbPwd)

  ${{ each dir in $BUILD_ARTIFACTSTAGINGDIRECTORY/*}}:
  - task: PublishBuildArtifacts@1
    inputs:
      pathtoPublish: $(Build.ArtifactStagingDirectory)/$dir
      artifactName: test-$(Build.BuildNumber).$(System.JobPositionInPhase).$dir
    displayName: Store test result
